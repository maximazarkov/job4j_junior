# Контрольные вопросы часть 001. Collections. Pro.
Ответы на повросы созданы для личного использования и за использование Вами данного материала я ответсвенности не несу.

### Оглавление проекта
**Список вопросов**
+ [Что такое генерики?](#Что-такое-генерики)
+ [Типы генериков](#Типы-генериков)
+ [Где хранится информация про Generics?](#Где-хранится-информация-про-Generics)
+ [Как можно получить тип Generics?](#Как-можно-получить-тип-Generics)
+ [Что такое итератор?](#Что-такое-итератор)
+ [Что такое коллекции?](#Что-такое-коллекции)
+ [Назовите базовые интерфейсы коллекций?](#Назовите-базовые-интерфейсы-коллекций)
+ [Расскажите реализации интерфейса List?](#Расскажите-реализации-интерфейса-List)
+ [Расскажите реализации интерфейса Set?](#Расскажите-реализации-интерфейса-Set)
+ [Расскажите реализации интерфейса Map?](#Расскажите-реализации-интерфейса-Map)
+ [Отличие ArrayList от LinkedList?](#Отличие-ArrayList-от-LinkedList)
+ [Отличие Set от List?](#Отличие-Set-от-List)
+ [Расскажите про методы Object hashCode и equals?](#Расскажите-про-методы-Object-hashCode-и-equals)
+ [Расскажите про реализации Map?](#Расскажите-про-реализации-Map)
+ [Расскажите, что такое коллизии в Map? Как с ними бороться?](#Расскажите-что-такое-коллизии-в-Map-Как-с-ними-бороться)
+ [Расскажите, что такое анализ алгоритма?](#Расскажите-что-такое-анализ-алгоритма)
+ [Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?](#Какая-временная-сложность-алгоритмов(O-нотация)-добавления-замены-и-удаления-в-каждой-из-коллекций-С-чем-связаны-отличия)
+ [Расскажите реализации данных очередей и стеков.](#Расскажите-реализации-данных-очередей-и-стеков)
+ [Расскажите про реализации деревьев.](#Расскажите-про-реализации-деревьев)
+ [Что такое loadFactor?](#Что-такое-loadFactor)

***
+ [Контакты](#Контакты)
***

## Ответы на вопросы
### Что такое генерики?
Обобщения (Generics) - параметризированные типы. Обобщения позволяют объявлять классы, интерфейсы и методы, где тип данных, которым они оперируют,
указан в виде параметра. Данная конструкция языка позволяет создавать интерфейсы, классы или методы, которые будут работать с разными типами данных
без изменения данных классов и методов. В свою очередь, на уровне компиляции будет обеспечиваться безопасность типов данных, что позволяет
писать надежный и универсальный код для повторного использвания. 

 [к оглавлению](#Оглавление-проекта)
### Типы генериков
Когда объявляется экземпляр обощенного типа, аргумент, передаваемый в качестве параметра типа, должен относиться
к ссылочному типу, но ни в коем случае не к примитивному типу наподобие int или char. В качестве параметра
обощенного класса, метода или интерефейса можно передать тип любого класса, если он не ограничек описанием
сигнатуры обобщенного класса, метода или интерфеса.

Для создания ограниченных типов применяют специальные конструкции в сигнатуре описание класса или интерфейса обобщения.
Например, для ограничения сверху, числовых типов Integer и Double и т.п., следует указать суперкласс указанных классов в
следующей конструкцией:
```java
class Get<T extends Number> {
//...
}
```
Эта конструкция указывает на то, что параметр типа Т может быть заменен только указанным суперклассом, т.е. Number
(включительно) или его подклассами (Integer, Double и т.п.). 

Накладывая на обобщенный класс несколько ограничений из класса и одного или нескольких интерфесов, для их объединения
следует воспользоваться лигической операцией &. При этом класс должен стоять первым:
```java
class Get<T extends MyClass & MyInterface> {
//...
}
```
Если требется наоборот "расширить" ограничения, чтобы тип совпадал с любым достоверным объектом класса, то следует воспользоваться _метасимвольным аргументом_ - __<?>__. Пример:
```java
class Stats<T extends Number> {
// Определить равество двух значений, ограниченных сигнатурой класса, например ограничены суперклассом Number
    boolean sameAvg(Stats<?> ob) {
// В данном случае не важно сравнивается тим Integer c Double или Double c Short, программа не ограничены типом вызываемого объекта, но ограничена типом Т класса.
        if (averege() == ob.averege())
            return true;
        return false;
    }
}
```
Метасимвольные аргументы так же можно ограничивать с помощью __<? extends _суперкласс_>__:

Для ограничения снизу для метасимвольного аргумента, необходимо указать оператор __super__ в его объявлении: __<? super _подкласс_>__.
В данном случае допустимы могут быть только те классы, которые являются суперклассами для указанного _подкласса_.

Если необходимо в качестве аргумента применить примитивный
тип, то его требуется обернуть в ссылочный тип, например: int в Integer. 

[к оглавлению](#Оглавление-проекта)
### Где хранится информация про Generics?
Виртуальная машина не оперирует объектами обобщенных типов - все объекты принадлежат обычным классам.

Всякий раз, когда определяется обобщенный тип, автоматически создается соотвествующий ему базовый, (т.н. "сырой") тип.
Имя этого типа совпадает с именем обобщенного типа с удаленными параметрами типа. Переменные типа _стираются_ и заменяются
ограничивающими типами (или типом __Object__, если переменная не имеет ограничений).

Не смотря на это клаассы все же сохраняют о себе некоторую информацию, о том, что он произведен от обобщенного клааса,
но он не может определить как он был сконструирован, т.е. какой класс был подставлен в замен параметра подстановочного класса.
Существует специальный API для рефлексии, который содержить ряд интерефейсов, с помощью которых можно вывести отчет о клаасе, 
о его методах, о параметров подстановочных типов, которые к данному классу применены.

Для рефлексии следует обратить внимание на следующие класс и интерфейсы, которые имплементирую интерфес Type и методы, 
которые возвращают объекты типа Type, TypeVariable и прочую информацию:
+ java.lang.Class\<T\>
+ java.lang.reflect.Method
+ java.lang.reflect.TypeVariable
+ java.lang.reflect.WildcardType
+ java.lang.reflect.ParameterizedType
+ java.lang.reflect.GenericArrayType 

[к оглавлению](#Оглавление-проекта)
### Как можно получить тип Generics?
Согласно статье на
[https://ru.stackoverflow.com](https://ru.stackoverflow.com/questions/742246/Можно-ли-определить-generics-тип-класса)
Дженерики существуют только на момент компиляции, в рантайме, когда приложение выполняется информации о дженериках стирается. 
Тип дженерика нельзя определить ни через мета информацию о полях класса, ни через метаинформацию о методах класса 
(принимаемые параметры, возвращаемый тип). Так же в java нельзя создать инстанс дженеричной переменной. Следовательно
получить тип дженеричной переменной класса, не имея ее инстанса невозможно.

Если у вас есть возможность получить инстанс переменной-дженерика(через рефлексию), то его тип можно определитьне
передавая его в конструктор, иначе ответ нет, нельзя

Одним из способов получить тип данных, который был передан в замен обобщенного класса - прочитать имя созданного 
производного класса:
```java
class Get<T> {
    T ob;
    Gen (T o) {
        ob = o;
    }
    void showType() {
        System.out.println("Типом Т является " + ob.getClass().getName());
    }     
}
```

[к оглавлению](#Оглавление-проекта)
### Что такое итератор?
Iterator - это интерфейс, который содержит 3 метода:
* hasNext() - проверяет, есть ли следующий элемент;
* next() - возвращает следующий элемент;
* remove() - удаляет текущий элемент.
Объект итератора позволяет выполнить перемещение по последовательности объектов с выбором каждого объекта этой последовательности.

[к оглавлению](#Оглавление-проекта)
### Что такое коллекции?
Каркас коллекций Collections Framework - каркас сложной иерархии интерфейсов и классов, позволяющий
эффективно управлять группами объектов. Коллекции представляют из себя контейнеры для хранения и обработки групп
объектов.
Примеры: List, Set, Queue, производные от них классы ArrayList? LinkedList, HashSet, TreeSet и т.д.
Параллельно идет инетрфей Map (поле). Он хоть и не входит в коллекции, но он так же применяется для структурированного
хранения объектов в фотмате ключ - значение. При этом и ключ и значения является объектом.

[к оглавлению](#Оглавление-проекта)
### Назовите базовые интерфейсы коллекций?
Базовыми интерфейсами коллекций являются интерфейс List (список), Set (множество) и Queue (Однсторння очередь).
Некоторые интерфейсы так же могут иметь дочерние интерфейсы и классы, напимер, Интерфейс Deque (двусторнняя очередь) расширяет интерфейс Queue
Не смотря на то, что инерфейс Map не расшитяет интерфейс Collection, он все же входит в состав Collection API. 

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации интерфейса List?
Интерфейс List реализует абстрактый класс AbstractList, унаследованный от класса AbstractCollection. В свою очередь AbstractList унаследует класс ArrayList.
Класс ArrayList представляет собой обычный обобщенный массив, который имеет методы по автоматическому увеличению размера данного массива путем копирования. Данная реализация
удобна при чтении данных.
Если требуется быстрая запись данных в контейнер, то лучше воспользоваться LinkedList - связным списком, который наследует AbstractSequentialList реализующий AbstractList
и реализует интерфейсы List, Queue и Dequeue.
В данном списке хранится ссылка на следующий и предыдущий объекты коллекции. Данная реализация позволяет быстро выполнять вставку и удаление элементов коллекции,
но чтение элемента занимает значительное время.
Так же есть реализации устаревший классов Vector и Stack, но данный классы являются устаревшими и не рекомендуется их использовать

Данные реализации не ограничиваю пользователя хранить дублирующие обьъекты в коллекции

Абстрактные классы введены для расширения возможностей пользователя создавать свои классы, расширяющие интерфейс Collection.

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации интерфейса Set?
Интерфейс Set реализует инетерфейс Collection. Основной особенностью я вляется то, что множества не содержат дубликаты, а так же имеют
некую абстрактную систему хранения данных. Самой известной реализацией множества Set является класс HashSet, который в место интексов применяет некоторые хэш-значение.
Данные хранятся в хэш-таблице.
Таким же популярным является класс TreeSet, который данные хранит в деревоводной структуре в изначально отсортированном виде.

Интерфей Set расширяет интерфейс SortedSet, который  позволяет бысто полуать первый, последний элемент множества,
а так же позволяет получать новую коллекцию с начала, с конца или с середины коллекиции

Интерфейс SortedSet расширяет интерфейс NavigableSet, который позволяет работать с коллекцией , так сказать в условных диапазонах.
Например, можно выбрать все элементы множества, которые больше определенного значения и т.п.

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации интерфейса Map?
У интерфейса Map из Java Collections Framework есть несколько реализаций, и у некоторых из них есть очень интересные свойства,
знание которых поможет Вам эффективно решать определенные задачи. Отличия между двумя распространенными реализациями - HashMap и
TreeMap - такие же, как между HashSet и TreeSet (тем более, что последние реализованы на основе первых).
Так же есть еще интересные реализации - LinkedHashMap, EnumMap, WeakHashMap.

С LinkedHashMap все просто - получаете преимущества поика по хэш коду и, в дополнение к этому, порядок элементов при итерации
будет таким же, как при вставке. С помощью конструкторов этого класса можно задать некоторые параметры, которые будут влиять
на скорость работы, объем занимаемой памяти, а также на порядок элементов при итерации. Последнее особенно интересно, так как 
позволяет использовать LinkedHashMap в очень интересных решениях, одно из которых - простейший LRU-кэш.

С EnumMap все еще проще - обычный Map, где ключами есть значения enum. Не все это знают, но эффективность хранения элементов
и скорость работы намного превышает другие реализации, при использовании перечислений для ключей.

Реализация WeakHashMap основана на использовании слабых ссылок (WeakReference) для ключей. Это позволяет эффективно использовать
Map для временного хранения информации, где запись будет удалятся, когда сборщик мусора в Java удалит объект ключа. Для
продуктивного и правильного использования этой реализации необходимо понимание механизма ссылок в Java и работы сборщика мусора.

[источник](http://blog.yuriytkach.com/2013/07/map-interface-implementations.html)

[к оглавлению](#Оглавление-проекта)
### Отличие ArrayList от LinkedList?
Основным отличием структура соллекции. ArrayList - массив, LinkedList - коллекция объектов в виде связного списка,
элементы которого точно занют пердыдущий и следующий элементы. Соответственно у них разная скорость добавления, поиска (чтения) и удаления элементов
* В ArrayList бастро выполняется добавление в конец списка, если требуется добавить элемент в середину списка, то все элементы,
который находятся справа, необходимо сдвинут. Для LinkedList этой проблемы не существует, т.е. добавление в любое место коллекции
занимает одно и то же время, т.к. просто изменяются ссылкы на соседние объекты.
* Поиск (чтение) у ArrayList происходит быстро и для всех элементов одинаковое. В LinkedList - с увеличением размера коллекции скорость поиска увеличивается,
т.к. поиск всегда наичается с начала.
* Удаление, походе на добавление, только в обратном порядке.

[к оглавлению](#Оглавление-проекта)
### Отличие Set от List?
в List могут харниться дублекаты, в Set - нет.
List - упорядоченная коллекция, а Set - нет.
В List может находится сколько угодно null, а в Set максимум - один.
Set быстрее. Например, реализация HeshSet решает проблемы ArrayList и LinkedList в части скорости доступа и операций с элементами. 

[к оглавлению](#Оглавление-проекта)
### Расскажите про методы Object hashCode и equals?
Методы Object hashCode() и equals() имеют минимальную базовую реализацию, и по сути долны быть переопределены
в классах, где применяются. Ниже примеры их реализации в классе Object:
```java
    public native int hashCode();
```

```java
    public boolean equals(Object obj) {
        return (this == obj);
    }
```
 
 Метод equals() предназначен для сравнения объектов, даже если ини имею разные ссылки и хранятся 
 в разных местах памяти. В базовой версии данный метод просто сравнивает ссылки и даже если объеты 
 равны, но хранятся в разных местах в памяти, то метод вернет false. По этой причине, при разработке 
 класса, который бует использовать метод equals(), в методе необходимо указать поля, по которыб будет
 производиться сравнение, а так же метод их сраненния. Т.к. обычно данный метод получается очень
 "тяжелым" для выполнения из-за сложных расчетов, то изначально применяют
 
 метод hashCode() - метод, генерирующий некий хеш-код, в определенном диапазоне не превышающем
 диапазон int. В классе Object метод hashCode() никак не реализован и при разработке необходмио 
 написать функцию расчета хеш-кода.
 
    
 Рассмотрим пример из книги Эффективное программирование, Дж.Блох, в качестве примера
 
 ```java
    @Override
    public boolean equals(Object o) {
        // проверяем, ссылается ли объект на самого себя?
        if (o == this) {
            return true;
        }
        // следом проверяем совпадают ли типы классов, родственники ли они?
        if (!(o instanceof PhoneNumber)) {
            return false;
        }
        //если фейс контроль пройден, то сверяем поля обьектов по определенных правиам, какие нам необходимы.
        PhoneNumber pn = (PhoneNumber) o;
        return pn.areaCode == areaCode && pn.lineNumber == lineNumber && pn.prefix == prefix;
    } 
```

Если не переопределить метод hashCode(), то при одинаковых объектах по equals() из-за
непереопределенного hashCode, данные объекты скорее всего будут иметь разный хэш-код,
т.к. метод hashCode класса Object по сути сравнивает ссылки на память. И соотвественно
одинаковые обьекты по содержимому, но ссозданные с помощью оператора new, будут
расположены в разных участках памяти, а соотвественно будут иметь разные хэши и никогда
не будут равны, если даже они 100% идентичны. 

Для устарнения данной проблемы необходимо создать обратное условие, когда возможны
совпадения по хэшкодам, а по equals совпадения не обязательны

Для тестирования рассмотри самую плохую реализаицю метода hashCode()

При такой реализации все элементы будут привязаны только к одному сегменту хэш-таблицы
и наша хэш-таблица превратиться в связный список, а соовтественно время доступа
до элементов увеличится с линейного до квадратичного. И соотвественно для любых
сравнений объектов, не зависимо, одниковое у них содержимое или нет, будет вызыватсья
метод equals(), что негативно сказывается на производительность.*/
```java
    @Override
    public int hashCode(){
        return 42;   // ОООЧЕНЬ ПЛОХО!!!! НИКОГДА ТАК НЕ ДЕЛАЙТЕ!!!
    }
```

Согласно разным реализациям JVM методы вычисления хэш-кодов меняются, по этому
достаточно понимать, что основная задача метода заключается в том,
чтобы все важные поля, перевести в примитивы, затем примитивы привести к int,
затем распределить значение как можно в более широком диапазоне int. Если вычисляются
хэш-коды объектов или массивов, то необходимо применить рекурсия по вычислению их
equals() и hashCode().

Главное правило, метода hashCode должен быть как можно легче, но при этом возврщать
как можно более уникальые хэш-коды. А уже на equals() повесить всю тяжелую работу.

Есть один важный нюанс. Это умножение результата в методе hashCode() на 31. Зделано
это для равномерного распредения хэш-кодов, но простое число 31 еще выбрано по тому, что
его можно получить простым сдвигом, что является легкой операцией для процессора

31 * i == (i << 5) - i.


#####ПРАВИЛЬНАЯ, НО НЕ ЛУЧШАЯ РЕАЛИЗАЦИЯ
```java
//    @Override
//    public int hashCode() {
//        int result = 17;  // число 17 выбрано произвольно. обычно выбирают число 1.
//        result = 31 * result + areaCode;
//        result = 31 * result + prefix;
//        result = 31 * result + lineNumber;
//        return result;
//    }
```
```java
    /*ИЛИ начиная с Java 7 можно переписать так...*/
    @Override
    public int hashCode() {
        return Objects.hash(areaCode, prefix, lineNumber);
    }

```
Для сокращения расходов вычислений на расчет хэш-таблиц, можно выполнять расчет
либо при создании объекта, либо с помощью ленивой инициализации поля. содержащего
хэш-код, высчитовать его при первом вызове и сохранять в теле обхекта до момента,
когда объект потребуется именить

ЛУЧШАЯ РЕАЛИЗАЦИЯ - РАЗРАБОТКА ОПТИМИЗИРОВАННЫХ ХЭШ-ФУНКЦИЯ, НО ДОСТИГАЕТСЯ ТОЛЬКО
ПОСТОЯННЫМИ ИССЛЕДОВАНИЯМИ.
 

[к оглавлению](#Оглавление-проекта)
### Расскажите про реализации Map?
см. [Расскажите реализации интерфейса Map?](#Расскажите-реализации-интерфейса-Map)

[к оглавлению](#Оглавление-проекта)
### Расскажите, что такое коллизии в Map? Как с ними бороться?
Коллизия - когда два объекта (одинаковых или разных) получают один и тот же хэш-код.

Существует два основных способа разрешения коллизий:
+ Метод цепочек. В этом случае корзина (bucket) может хранить несколько элементов, и хранятся они, в большинстве случаев, в виде связного списка (linked list).
+ Метод открытой адресации. Здесь, при возникновении коллизии, происходит поиск некоторой свободной ячейки, куда и добавляется очередной элемент.

В Java, для разрешения коллизий, используется метод цепочек.

Изначально, корзина в HashMap представляет из себя связный список (linked list). При возникновении коллизии, очередная пара добавляется в этот список.

В последних версиях JDK, в случае, если размер связного списка становится более 8 (константа TREEIFY_THRESHOLD), то происходит преобразование связного
списка в дерево, при этом, найти элемент в HashMap в худшем случае уже можно за O(log(n)), а не за O(n), как в связном списке.
[источник](https://ru.stackoverflow.com/questions/676236/Коллизии-в-map-java)


[к оглавлению](#Оглавление-проекта)
### Расскажите, что такое анализ алгоритма?
Почитав книги "структуры данных и алгоритмы" R Lafore и "Грокаем алгоритмы", можно сказать кратко,
Что из-за отсутствия универсальной структуры данных, для разных задачь применяют разные структуры 
данных, чащще всего из встроенной Callection API. Разные структуры данных имеют зарные характеристики
по сохранению, поиску, удалению элементов структуры данных, соотвественно данные характеристики 
могут сильно влиять на скорость выполнения программы, а так же вызывать разного рода ошибки
переполнения памяти или прочих исключений.

Так вот, анализ алгоритма позволяет выбрать оптимальную структуру данных для определенной задачи. 

[к оглавлению](#Оглавление-проекта)
### Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? С чем связаны отличия?

Коллекция  | add()     | add(index, element) | get()     | swap()    | delete()
-----------|-----------|---------------------|-----------|-----------|---------
ArrayList  | O(1)      | O(n)                | O(1)      | O(1)      | O(n)
LinkedList | O(1)      | O(1)                | O(n)      | O(n)      | O(1)
HashSet    | O(1)      | O(1)                | O(1)      | O(1)      | O(1)
HashSet*   | O(n)      | O(n)                | O(n)      | O(n)      | O(n)
TreeSet    | O(log(n)) | O(log(n))           | O(log(n)) | O(log(n)) | O(log(n))

где в заголовках указаны условные названия методов:
* add() - добавление в начало или конец списка (зависит от коллекции)
* add(index, element) - добавление в середину коллекции по индексу 
* get() - получить элемент
* swap() - заменить элемент 
* delete() - удаление объекта из коллекции

Примечание: <br> \* - наихудшее состояние


- [статья Сложность времени коллекций Java](https://www.codeflow.site/ru/article/java-collections-complexity) 
- [Шпаргалка на habr.com](https://habr.com/ru/post/188010/)

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации данных очередей и стеков.
Здесь оговорюсь кратко
Очередь - Queue, принцип - FIFO
Стек - Stack, принцип LIFO

[к оглавлению](#Оглавление-проекта)
### Расскажите про реализации деревьев.

[к оглавлению](#Оглавление-проекта)
### Что такое loadFactor?
коэффициент загруженности, при превышении которого происходит автоматическое изменение размера коллекции HashSet или карты Map.
Обычно он выставляется равным 0,75 или 75%. Может назодится в пределах от 0 до 1. 

[к оглавлению](#Оглавление-проекта)


### Контакты
Если Вас что-то заинтересовало и у Вас есть вопросы по данному проекту, обращайтесь:
+ Email: aza-maxim@yandex.ru
+ Telegram: @azamaxim

[к оглавлению](#Оглавление-проекта)
