package ru.job4j.list;

import java.util.Iterator;
import java.util.Stack;

/**
 * Нужно реализовать очередь.
 *
 * public class SimpleQueue<T> {
 *    public <T> poll()
 *
 *    public void push(T value);
 * }
 *
 * Метод poll() - должен возвращать значение и удалять его из коллекции.
 * Метод push(T value) - помещает значение в коллекцию.
 *
 * Внутри очереди нужно использовать Стеки из задания 5.3.3. Используя контейнер на базе связанного списка создать контейнер Stack
 *
 * Описание Queue - очередь. Описывается FIFO - first input first output.
 *
 * То есть, первый зашел и первый вышел. Например.
 *
 * push(1);
 * push(2);
 * push(3);
 *
 * poll() - 1
 * poll() - 2
 * poll() - 3
 *
 * Это задание является тестовым заданием на собеседованиях.
 * @param <T>
 */
public class SimpleQueue<T> {
//    Меня сбила в заджании вот эта строчка, по этому применил прямой вызов SimpleDynamicLinkedList<>().
//    * Внутри очереди нужно использовать Стеки из задания 5.3.3. Используя контейнер на базе связанного списка создать контейнер Stack
//    Удалим их.
//    Применим немного иной подход. Создадим объекты SimpleDynamicLinkedList через SimpleStack
    private SimpleStack<T> inputStack = new SimpleStack<>();
    private SimpleStack<T> outputStack = new SimpleStack<>();


    /**
     * метод, прежде чем извлечь элемент, делать "переворот" второй коллекции путем сохранения ее в первой коллекции.
     * После пермещения первый введенный элемент оказываетс на вершине стека - коллекции, но и удаляется по LIFO, т.к.
     * считается,что они пришел последним. Благодяря данным переворотам получается эффект FIFO.
     * @return
     */
    public T poll() {
        // здесь применяется интересный метод.
//        если второй стек пустой, то мы в него загружаем из первого все элементы, при том, что первый стек очищается
//        повтоорное заполенение второго стека будет выполнено только при его полном очищении.
//        при этом первый стек может беспрепятсвенно заполнятся параллельно до следующей "перекачки".
        if (outputStack.isEmpty()) {
            while (!inputStack.isEmpty()) {
                outputStack.push(inputStack.poll());
            }
        }
//        далее, пока не кончатся данные в обоих стеках, будет возвращать данные из второго стека.
//        если оба стека буду очищены, то вернем null
        return (outputStack.isEmpty()) ? null : outputStack.poll();
    }

    /**
     * метод, прежде чем сохранить элемент, делать "переворот" первой коллекции путем сохранения ее во второй коллекции,
     * но при этом последний - новый элемент всегда остается в первой коллекции.
     * @param value - единственный элемент, который будет сохранен в первой коллекции, и перемещен во вторую при
     *              добавлении следующего элемента
     */
    public void push(T value) {
        // не заморачиваясь все складываем в первый стек...
        inputStack.push(value);
    }
}
