# Контрольные вопросы часть 001. Collections. Pro.
Ответы на повросы созданы для личного использования и за использование Вами данного материала я ответсвенности не несу.

### Оглавление проекта
**Список вопросов**
+ [Что такое генерики?](#Что-такое-генерики?)
+ [Типы генериков?](#Типы-генериков?)
+ [Где хранится информация про Generics?](#Где-хранится-информация-про-Generics?)
+ [Как можно получить тип Generics?](#Как-можно-получить-тип-Generics?)
+ [Что такое итератор?](#Что-такое-итератор?)
+ [Что такое коллекции?](#Что-такое-коллекции?)
+ [Назовите базовые интерфейсы коллекций?](#Назовите-базовые-интерфейсы-коллекций?)
+ [Расскажите реализации интерфейса List?](#Расскажите-реализации-интерфейса-List?)
+ [Расскажите реализации интерфейса Set?](#Расскажите-реализации-интерфейса-Set?)
+ [Расскажите реализации интерфейса Map?](#Расскажите-реализации-интерфейса-Map?)
+ [Отличие ArrayList от LinkedList?](#Отличие-ArrayList-от-LinkedList?)
+ [Отличие Set от List?](#Отличие-Set-от-List?)
+ [Расскажите про методы Object hashCode и equals?](#Расскажите-про-методы-Object-hashCode-и-equals?)
+ [Расскажите про реализации Map?](#Расскажите-про-реализации-Map?)
+ [Расскажите, что такое коллизии в Map? Как с ними бороться?](#Расскажите,-что-такое-коллизии-в-Map?-Как-с-ними-бороться?)
+ [Расскажите, что такое анализ алгоритма?](#Расскажите,-что-такое-анализ-алгоритма?)
+ [Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? . С чем связаны отличия?](#Какая-временная-сложность-алгоритмов(O-нотация)-добавления,-замены-и-удаления-в-каждой-из-коллекций?-.-С-чем-связаны-отличия?)
+ [Расскажите реализации данных очередей и стеков.](#Расскажите-реализации-данных-очередей-и-стеков.)
+ [Расскажите про реализации деревьев.](#Расскажите-про-реализации-деревьев.)
+ [Что такое loadFactor?](#Что-такое-loadFactor?)

***
+ [Контакты](#Контакты)
***

## Ответы на вопросы
### Что такое генерики?
Обобщения (Generics) - параметризированные типы. Обобщения позволяют объявлять классы, интерфейсы и методы, где тип данных, которым они оперируют,
указан в виде параметра. Данная конструкция языка позволяет создавать интерфейсы, классы или методы, которые будут работать с разными типами данных
без изменения данных классов и методов. В свою очередь, на уровне компиляции будет обеспечиваться безопасность типов данных, что позволяет
писать надежный и универсальный код для повторного использвания. 

 [к оглавлению](#Оглавление-проекта)
### Типы генериков?
Когда объявляется экземпляр обощенного типа, аргумент, передаваемый в качестве параметра типа, должен относиться
к ссылочному типу, но ни в коем случае не к примитивному типу наподобие int или char. В качестве параметра
обощенного класса, метода или интерефейса можно передать тип любого класса, если он не ограничек описанием
сигнатуры обобщенного класса, метода или интерфеса.

Для создания ограниченных типов применяют специальные конструкции в сигнатуре описание класса или интерфейса обобщения.
Например, для ограничения сверху, числовых типов Integer и Double и т.п., следует указать суперкласс указанных классов в
следующей конструкцией:
```java
class Get<T extends Number> {
//...
}
```
Эта конструкция указывает на то, что параметр типа Т может быть заменен только указанным суперклассом, т.е. Number
(включительно) или его подклассами (Integer, Double и т.п.). 

Накладывая на обобщенный класс несколько ограничений из класса и одного или нескольких интерфесов, для их объединения
следует воспользоваться лигической операцией &. При этом класс должен стоять первым:
```java
class Get<T extends MyClass & MyInterface> {
//...
}
```
Если требется наоборот "расширить" ограничения, чтобы тип совпадал с любым достоверным объектом класса, то следует воспользоваться _метасимвольным аргументом_ - __<?>__. Пример:
```java
class Stats<T extends Number> {
// Определить равество двух значений, ограниченных сигнатурой класса, например ограничены суперклассом Number
    boolean sameAvg(Stats<?> ob) {
// В данном случае не важно сравнивается тим Integer c Double или Double c Short, программа не ограничены типом вызываемого объекта, но ограничена типом Т класса.
        if (averege() == ob.averege())
            return true;
        return false;
    }
}
```
Метасимвольные аргументы так же можно ограничивать с помощью __<? extends _суперкласс_>__:

Для ограничения снизу для метасимвольного аргумента, необходимо указать оператор __super__ в его объявлении: __<? super _подкласс_>__.
В данном случае допустимы могут быть только те классы, которые являются суперклассами для указанного _подкласса_.

Если необходимо в качестве аргумента применить примитивный
тип, то его требуется обернуть в ссылочный тип, например: int в Integer. 

[к оглавлению](#Оглавление-проекта)
### Где хранится информация про Generics?
Виртуальная машина не оперирует объектами обобщенных типов - все объекты принадлежат обычным классам.

Всякий раз, когда определяется обобщенный тип, автоматически создается соотвествующий ему базовый, (т.н. "сырой") тип.
Имя этого типа совпадает с именем обобщенного типа с удаленными параметрами типа. Переменные типа _стираются_ и заменяются
ограничивающими типами (или типом __Object__, если переменная не имеет ограничений).

Не смотря на это клаассы все же сохраняют о себе некоторую информацию, о том, что он произведен от обобщенного клааса,
но он не может определить как он был сконструирован, т.е. какой класс был подставлен в замен параметра подстановочного класса.
Существует специальный API для рефлексии, который содержить ряд интерефейсов, с помощью которых можно вывести отчет о клаасе, 
о его методах, о параметров подстановочных типов, которые к данному классу применены.

Для рефлексии следует обратить внимание на следующие класс и интерфейсы, которые имплементирую интерфес Type и методы, 
которые возвращают объекты типа Type, TypeVariable и прочую информацию:
+ java.lang.Class\<T\>
+ java.lang.reflect.Method
+ java.lang.reflect.TypeVariable
+ java.lang.reflect.WildcardType
+ java.lang.reflect.ParameterizedType
+ java.lang.reflect.GenericArrayType 

[к оглавлению](#Оглавление-проекта)
### Как можно получить тип Generics?
Согласно статье на
[https://ru.stackoverflow.com](https://ru.stackoverflow.com/questions/742246/Можно-ли-определить-generics-тип-класса)
Дженерики существуют только на момент компиляции, в рантайме, когда приложение выполняется информации о дженериках стирается. 
Тип дженерика нельзя определить ни через мета информацию о полях класса, ни через метаинформацию о методах класса 
(принимаемые параметры, возвращаемый тип). Так же в java нельзя создать инстанс дженеричной переменной. Следовательно
получить тип дженеричной переменной класса, не имея ее инстанса невозможно.

Если у вас есть возможность получить инстанс переменной-дженерика(через рефлексию), то его тип можно определитьне
передавая его в конструктор, иначе ответ нет, нельзя

Одним из способов получить тип данных, который был передан в замен обобщенного класса - прочитать имя созданного 
производного класса:
```java
class Get<T> {
    T ob;
    Gen (T o) {
        ob = o;
    }
    void showType() {
        System.out.println("Типом Т является " + ob.getClass().getName());
    }     
}
```

[к оглавлению](#Оглавление-проекта)
### Что такое итератор?
Iterator - это интерфейс, который содержит 3 метода:
* hasNext() - проверяет, есть ли следующий элемент;
* next() - возвращает следующий элемент;
* remove() - удаляет текущий элемент.
Объект итератора позволяет выполнить перемещение по последовательности объектов с выбором каждого объекта этой последовательности.

[к оглавлению](#Оглавление-проекта)
### Что такое коллекции?
Каркас коллекций Collections Framework - каркас сложной иерархии интерфейсов и классов, позволяющий
эффективно управлять группами объектов. Коллекции представляют из себя контейнеры для хранения и обработки групп
объектов.
Примеры: List, Set, Queue, производные от них классы ArrayList? LinkedList, HashSet, TreeSet и т.д.
Параллельно идет инетрфей Map (поле). Он хоть и не входит в коллекции, но он так же применяется для структурированного
хранения объектов в фотмате ключ - значение. При этом и ключ и значения является объектом.

[к оглавлению](#Оглавление-проекта)
### Назовите базовые интерфейсы коллекций?

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации интерфейса List?

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации интерфейса Set?

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации интерфейса Map?

[к оглавлению](#Оглавление-проекта)
### Отличие ArrayList от LinkedList?

[к оглавлению](#Оглавление-проекта)
### Отличие Set от List?

[к оглавлению](#Оглавление-проекта)
### Расскажите про методы Object hashCode и equals?

[к оглавлению](#Оглавление-проекта)
### Расскажите про реализации Map?

[к оглавлению](#Оглавление-проекта)
### Расскажите, что такое коллизии в Map? Как с ними бороться?

[к оглавлению](#Оглавление-проекта)
### Расскажите, что такое анализ алгоритма?

[к оглавлению](#Оглавление-проекта)
### Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? . С чем связаны отличия?

[к оглавлению](#Оглавление-проекта)
### Расскажите реализации данных очередей и стеков.

[к оглавлению](#Оглавление-проекта)
### Расскажите про реализации деревьев.

[к оглавлению](#Оглавление-проекта)
### Что такое loadFactor?

[к оглавлению](#Оглавление-проекта)


### Контакты
Если Вас что-то заинтересовало и у Вас есть вопросы по данному проекту, обращайтесь:
+ Email: aza-maxim@yandex.ru
+ Telegram: @azamaxim

[к оглавлению](#Оглавление-проекта)
